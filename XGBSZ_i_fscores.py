# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FEgfGym5CGjEZd68f-glTpKmiWFitlmq
"""

import pandas as pd

import xgboost as xgb

import operator
import random

from sklearn.cross_validation import train_test_split
from sklearn.model_selection import KFold
from sklearn.metrics import roc_auc_score

import time

!pip install -U -q PyDrive
from pydrive.auth import GoogleAuth
from pydrive.drive import GoogleDrive
from google.colab import auth
from oauth2client.client import GoogleCredentials

auth.authenticate_user()
gauth = GoogleAuth()
gauth.credentials = GoogleCredentials.get_application_default()
drive = GoogleDrive(gauth)

def importaj(t):
  kljucevi={'Bilance_za_sektor_F_za_1_godina.csv':'1ZPSZ_qfZP_AzIacEmjcRk0B0EULI1rnx',
            'Bilance_za_sektor_F_za_2_godina.csv':'1E1H8hZgGkc83HMt1lWtbLswUsmgbeVkU',
            'Bilance_za_sektor_F_za_3_godina.csv':'1iDO9jwfWiJT_D3SYDYgodvi6b5RJIboO',
            'Bilance_za_sektor_F_za_4_godina.csv':'1bW-R50lYWnuPkbYfXI3feof9eawH6UJ4',
            'Bilance_za_sektor_F_za_5_godina.csv':'1Nt_E-Ia2dfc5cUzD94BogoZupJDbx6kj'
           }
  
  downloaded = drive.CreateFile({'id':list(kljucevi.values())[t-1]})
  downloaded.GetContentFile(list(kljucevi.keys())[t-1])
  X = pd.read_csv(filepath_or_buffer = list(kljucevi.keys())[t-1])
  X.rename(columns={'Unnamed: 0':'Idx priasnje bilance'},inplace=True)
  #X = bilanca.parse(bilanca.sheet_names[0],dtype=str)
  return X

X1 = importaj(1)
X2 = importaj(2)
X3 = importaj(3)
X4 = importaj(4)
X5 = importaj(5)

def Vrati_X_sa_stupcima_B_i_SubjectTaxNoID_i_y_Predstecaj(X):
  prvi = list(X.columns).index("001B")
  zadnji = list(X.columns).index("380B")
  ind = list(X.columns).index("SubjectTaxNoID")
  
  y = X["Predsteƒçaj"]
  X = X.iloc[:,[ind]+list(range(prvi,zadnji))]
  return X , y

def xgb_sz(X1_train,y1_train,T,broj_sintetickih,param):
    prosjecna_evaluacija  = 0
    prosjecna_evaluacija_train = 0
    
    ops = { "+": operator.add, "-": operator.sub ,"/": operator.truediv, "*": operator.mul}
    ops2 = { "+": operator.add, "-": operator.sub , "*": operator.mul}#"/": operator.truediv,}
    
    kf = KFold(n_splits=10)
    
    for train_index, test_index in kf.split(X1_train):
      DataFrame_X_skojim_radim = (X1_train.iloc[train_index,:]).copy()
      DataFrame_y_skojim_radim = (y1_train.iloc[train_index]).copy()
      
      DataFrame_X_skojim_testiram = (X1_train.iloc[test_index,:]).copy()
      DataFrame_y_skojim_testiram = (y1_train.iloc[test_index]).copy()
      
      dtrain = xgb.DMatrix(data= DataFrame_X_skojim_radim , label=DataFrame_y_skojim_radim.values)
      booster_ = xgb.train(params = param , dtrain = dtrain , xgb_model = None , num_boost_round = 1 )
      
      for i in range(1,(T-1)):
        rj=booster_.get_fscore()
        N = sum(rj.values())
        vjerojatnosti = {key: rj[key]/N for key in rj.keys()}        
        #DataFrame_X_skojim_radim=DataFrame_X_skojim_radim[list(rj.keys())]
# =============================================================================
#         lista_znacajki=[] #koje su u nekom stablu
#         for key in rj.keys():
#             if (key[0]=='f'):
#                 lista_znacajki.append(str(int(key[1:])+1)+'B')
#             else:
#                 lista_znacajki.append(key)
#                 
#         print(list(DataFrame_X_skojim_radim.columns))
#         print(lista_znacajki)
#         print(list(rj.keys()))
#         
#         DataFrame_X_skojim_radim=DataFrame_X_skojim_radim[lista_znacajki]
# =============================================================================

        broj_sintetickih1 = broj_sintetickih

        while (broj_sintetickih1!=0):
          izabrane_var = random.choices(list(vjerojatnosti.keys()), weights = list(vjerojatnosti.values()), k=2)
          if (0 in DataFrame_X_skojim_radim[izabrane_var[1]].values):
            izabrana_operacija = random.choices(list(ops2.keys()) , k=1)
          else: izabrana_operacija = random.choices(list(ops.keys()) , k=1)
        
          if ((izabrane_var[0] + izabrana_operacija[0] + izabrane_var[1]) not in list(DataFrame_X_skojim_radim.columns)):
            DataFrame_X_skojim_radim[ izabrane_var[0] + izabrana_operacija[0] + izabrane_var[1] ] = ops[izabrana_operacija[0]](DataFrame_X_skojim_radim[izabrane_var[0]], DataFrame_X_skojim_radim[izabrane_var[1]])
            DataFrame_X_skojim_testiram[ izabrane_var[0] + izabrana_operacija[0] + izabrane_var[1] ] = ops[izabrana_operacija[0]](DataFrame_X_skojim_testiram[izabrane_var[0]], DataFrame_X_skojim_testiram[izabrane_var[1]])
            broj_sintetickih1 -= 1        

        dtrain = xgb.DMatrix(data = DataFrame_X_skojim_radim , label=DataFrame_y_skojim_radim.values)
        booster_ = xgb.train(params = param , dtrain = dtrain , xgb_model = booster_ , num_boost_round = 1 )

      dtest = xgb.DMatrix(data = DataFrame_X_skojim_testiram)#[dtrain.feature_names])#.as_matrix())#, label = DataFrame_y_skojim_testiram.values)
      y_pred = booster_.predict(dtest)

      trenutna_evaluacija = roc_auc_score(y1_train.iloc[test_index],y_pred)
      
      prosjecna_evaluacija += trenutna_evaluacija  
      
      dtest_train= xgb.DMatrix(data = DataFrame_X_skojim_radim)
      y_pred_train = booster_.predict(dtest_train)
      trenutna_evaluacija_train = roc_auc_score(y1_train.iloc[train_index],y_pred_train)
      prosjecna_evaluacija_train += trenutna_evaluacija_train      
      
    print("Prosjecna evaluacija na testnom dijelu: {}".format(prosjecna_evaluacija/10))
    print("Prosjecna evaluacija na trening dijelu: {}".format(prosjecna_evaluacija_train/10))

X1 , y1 = Vrati_X_sa_stupcima_B_i_SubjectTaxNoID_i_y_Predstecaj(X1)
X2 , y2 = Vrati_X_sa_stupcima_B_i_SubjectTaxNoID_i_y_Predstecaj(X2)
X3 , y3 = Vrati_X_sa_stupcima_B_i_SubjectTaxNoID_i_y_Predstecaj(X3)
X4 , y4 = Vrati_X_sa_stupcima_B_i_SubjectTaxNoID_i_y_Predstecaj(X4)
X5 , y5 = Vrati_X_sa_stupcima_B_i_SubjectTaxNoID_i_y_Predstecaj(X5)

X1_train, X1_test, y1_train, y1_test = train_test_split(X1.drop(["SubjectTaxNoID"],axis=1),y1,random_state=0)

T = 10
broj_sintetickih = 30
param={'eta': 0.16000000000000003, 'max_depth': 6, 'lambda': 0.5, 'subsample': 0.8, 'objective':'binary:logistic'}

t0 = time.time()
xgb_sz(X1_train,y1_train,T,broj_sintetickih,param)
t1 = time.time()
total = t1-t0
print(total)

X2_train, X2_test, y2_train, y2_test = train_test_split(X2.drop(["SubjectTaxNoID"],axis=1),y2,random_state=0)

T = 10
broj_sintetickih = 30
param={'eta': 0.16000000000000003, 'max_depth': 6, 'lambda': 0.5, 'subsample': 0.8, 'objective':'binary:logistic'}

t0 = time.time()
xgb_sz(X2_train,y2_train,T,broj_sintetickih,param)
t1 = time.time()
total = t1-t0
print(total)

X3_train, X3_test, y3_train, y3_test = train_test_split(X3.drop(["SubjectTaxNoID"],axis=1),y3,random_state=0)

T = 10
broj_sintetickih = 30
param={'eta': 0.16000000000000003, 'max_depth': 6, 'lambda': 0.5, 'subsample': 0.8, 'objective':'binary:logistic'}

t0 = time.time()
xgb_sz(X3_train,y3_train,T,broj_sintetickih,param)
t1 = time.time()
total = t1-t0
print(total)

X4_train, X4_test, y4_train, y4_test = train_test_split(X4.drop(["SubjectTaxNoID"],axis=1),y4,random_state=0)

T = 10
broj_sintetickih = 30
param={'eta': 0.16000000000000003, 'max_depth': 6, 'lambda': 0.5, 'subsample': 0.8, 'objective':'binary:logistic'}

t0 = time.time()
xgb_sz(X4_train,y4_train,T,broj_sintetickih,param)
t1 = time.time()
total = t1-t0
print(total)

X5_train, X5_test, y5_train, y5_test = train_test_split(X5.drop(["SubjectTaxNoID"],axis=1),y5,random_state=0)

T = 10
broj_sintetickih = 30
param={'eta': 0.16000000000000003, 'max_depth': 6, 'lambda': 0.5, 'subsample': 0.8, 'objective':'binary:logistic'}

t0 = time.time()
xgb_sz(X5_train,y5_train,T,broj_sintetickih,param)
t1 = time.time()
total = t1-t0
print(total)

# ZA x1 napisat kako dobit scorove
param={'learning_rate': 0.16000000000000003, 'max_depth': 6, 'reg_lambda': 0.5, 'subsample': 0.8}
dtrain = xgb.DMatrix(data= X1.drop(["SubjectTaxNoID"],axis=1) , label=y1.values)
booster_ = xgb.train(params = param , dtrain = dtrain , xgb_model = None , num_boost_round = 100 )

fscore=booster_.get_fscore()
imena=list(fscore.keys())
vjerojatnosti=list(fscore.values())
total=sum(vjerojatnosti)
for key in fscore.keys():
  fscore[key]=fscore[key]/total
sorted_ = sorted(fscore.items(), key=operator.itemgetter(1),reverse=True)
sorted_